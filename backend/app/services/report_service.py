"""Report storage service for LangGraph tool results.

This service manages the Redis-based storage for tool execution reports.
Reports are generated by LangGraph when executing sync tools and can be
viewed later in a Reports module.

Usage:
    from app.services.report_service import get_report_service

    report_service = get_report_service()
    report_id = await report_service.save_report(
        tool_name="summarize_node",
        node_id="obs-123",
        content="Summary of the observation...",
    )
    report = await report_service.get_report(report_id)
"""

import json
import logging
from datetime import datetime
from typing import Any, Dict, List, Optional
import uuid

from app.db.redis import redis_conn
from app.models.job_models import Report, ReportResponse, ReportListResponse

logger = logging.getLogger(__name__)

# Redis key prefixes
REPORT_PREFIX = "report:"
REPORT_INDEX_BY_NODE = "reports:node:"
REPORT_INDEX_BY_EDGE = "reports:edge:"
REPORT_INDEX_BY_TOOL = "reports:tool:"


class ReportService:
    """Service for managing tool execution reports.

    Uses Redis for:
    - Report storage: hash at report:{id}
    - Indexes: sets for quick lookup by node_id, edge_id, tool_name
    """

    def __init__(self):
        """Initialize report service."""
        self._redis = None

    @property
    def redis(self):
        """Get Redis client, lazily initialized."""
        if self._redis is None:
            try:
                self._redis = redis_conn.get_client()
            except RuntimeError:
                logger.warning("Redis not available for report storage")
                return None
        return self._redis

    async def save_report(
        self,
        tool_name: str,
        content: str,
        node_id: Optional[str] = None,
        edge_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Save a report.

        Args:
            tool_name: Name of the tool that generated this report
            content: Report content
            node_id: Associated node ID (optional)
            edge_id: Associated edge ID (optional)
            metadata: Additional metadata (optional)

        Returns:
            Report ID
        """
        report_id = str(uuid.uuid4())
        created_at = datetime.utcnow()

        if self.redis:
            # Store report data in Redis hash
            await self.redis.hset(
                f"{REPORT_PREFIX}{report_id}",
                mapping={
                    "id": report_id,
                    "tool_name": tool_name,
                    "node_id": node_id or "",
                    "edge_id": edge_id or "",
                    "content": content,
                    "metadata": json.dumps(metadata or {}),
                    "created_at": created_at.isoformat(),
                }
            )

            # Update indexes
            await self.redis.sadd(f"{REPORT_INDEX_BY_TOOL}{tool_name}", report_id)
            if node_id:
                await self.redis.sadd(f"{REPORT_INDEX_BY_NODE}{node_id}", report_id)
            if edge_id:
                await self.redis.sadd(f"{REPORT_INDEX_BY_EDGE}{edge_id}", report_id)

            logger.info(f"Saved report {report_id} for tool {tool_name}")
        else:
            logger.warning(f"Redis unavailable, report {report_id} not persisted")

        return report_id

    async def get_report(self, report_id: str) -> Optional[Report]:
        """Get report by ID.

        Args:
            report_id: Report ID

        Returns:
            Report if found, None otherwise
        """
        if not self.redis:
            return None

        data = await self.redis.hgetall(f"{REPORT_PREFIX}{report_id}")
        if not data:
            return None

        return self._parse_report(data)

    async def get_report_response(self, report_id: str) -> Optional[ReportResponse]:
        """Get report as response model.

        Args:
            report_id: Report ID

        Returns:
            ReportResponse if found, None otherwise
        """
        report = await self.get_report(report_id)
        if not report:
            return None

        return ReportResponse(
            id=report.id,
            tool_name=report.tool_name,
            node_id=report.node_id,
            edge_id=report.edge_id,
            content=report.content,
            metadata=report.metadata,
            created_at=report.created_at,
        )

    async def list_reports(
        self,
        tool_name: Optional[str] = None,
        node_id: Optional[str] = None,
        edge_id: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> ReportListResponse:
        """List reports with optional filtering.

        Args:
            tool_name: Filter by tool name
            node_id: Filter by node ID
            edge_id: Filter by edge ID
            limit: Maximum reports to return
            offset: Number of reports to skip

        Returns:
            ReportListResponse with reports and total count
        """
        if not self.redis:
            return ReportListResponse(reports=[], total=0)

        # Get report IDs from indexes
        report_ids: set = set()

        if tool_name:
            ids = await self.redis.smembers(f"{REPORT_INDEX_BY_TOOL}{tool_name}")
            report_ids.update(ids)
        elif node_id:
            ids = await self.redis.smembers(f"{REPORT_INDEX_BY_NODE}{node_id}")
            report_ids.update(ids)
        elif edge_id:
            ids = await self.redis.smembers(f"{REPORT_INDEX_BY_EDGE}{edge_id}")
            report_ids.update(ids)
        else:
            # Get all reports (scan for keys)
            async for key in self.redis.scan_iter(match=f"{REPORT_PREFIX}*"):
                # Extract ID from key
                report_id = key.replace(REPORT_PREFIX, "")
                report_ids.add(report_id)

        # Load reports
        reports: List[ReportResponse] = []
        for report_id in report_ids:
            data = await self.redis.hgetall(f"{REPORT_PREFIX}{report_id}")
            if not data:
                continue

            report = self._parse_report(data)
            reports.append(ReportResponse(
                id=report.id,
                tool_name=report.tool_name,
                node_id=report.node_id,
                edge_id=report.edge_id,
                content=report.content,
                metadata=report.metadata,
                created_at=report.created_at,
            ))

        # Sort by created_at descending
        reports.sort(key=lambda r: r.created_at, reverse=True)

        total = len(reports)
        reports = reports[offset:offset + limit]

        return ReportListResponse(reports=reports, total=total)

    async def list_reports_for_node(
        self,
        node_id: str,
        limit: int = 20,
    ) -> ReportListResponse:
        """List reports for a specific node.

        Args:
            node_id: Node ID
            limit: Maximum reports to return

        Returns:
            ReportListResponse with reports
        """
        return await self.list_reports(node_id=node_id, limit=limit)

    async def list_reports_for_edge(
        self,
        edge_id: str,
        limit: int = 20,
    ) -> ReportListResponse:
        """List reports for a specific edge.

        Args:
            edge_id: Edge ID
            limit: Maximum reports to return

        Returns:
            ReportListResponse with reports
        """
        return await self.list_reports(edge_id=edge_id, limit=limit)

    async def delete_report(self, report_id: str) -> bool:
        """Delete a report.

        Args:
            report_id: Report ID

        Returns:
            True if deleted, False if not found
        """
        if not self.redis:
            return False

        # Get report data first to clean up indexes
        data = await self.redis.hgetall(f"{REPORT_PREFIX}{report_id}")
        if not data:
            return False

        # Remove from indexes
        tool_name = data.get("tool_name", "")
        node_id = data.get("node_id", "")
        edge_id = data.get("edge_id", "")

        if tool_name:
            await self.redis.srem(f"{REPORT_INDEX_BY_TOOL}{tool_name}", report_id)
        if node_id:
            await self.redis.srem(f"{REPORT_INDEX_BY_NODE}{node_id}", report_id)
        if edge_id:
            await self.redis.srem(f"{REPORT_INDEX_BY_EDGE}{edge_id}", report_id)

        # Delete report
        await self.redis.delete(f"{REPORT_PREFIX}{report_id}")
        logger.info(f"Deleted report {report_id}")
        return True

    async def clear_reports_for_node(self, node_id: str) -> int:
        """Delete all reports for a node.

        Args:
            node_id: Node ID

        Returns:
            Number of reports deleted
        """
        if not self.redis:
            return 0

        report_ids = await self.redis.smembers(f"{REPORT_INDEX_BY_NODE}{node_id}")
        deleted = 0

        for report_id in report_ids:
            if await self.delete_report(report_id):
                deleted += 1

        return deleted

    async def clear_reports_for_edge(self, edge_id: str) -> int:
        """Delete all reports for an edge.

        Args:
            edge_id: Edge ID

        Returns:
            Number of reports deleted
        """
        if not self.redis:
            return 0

        report_ids = await self.redis.smembers(f"{REPORT_INDEX_BY_EDGE}{edge_id}")
        deleted = 0

        for report_id in report_ids:
            if await self.delete_report(report_id):
                deleted += 1

        return deleted

    async def clear_old_reports(self, older_than_days: int = 30) -> int:
        """Clear reports older than specified days.

        Args:
            older_than_days: Clear reports older than this many days

        Returns:
            Number of reports deleted
        """
        if not self.redis:
            return 0

        cutoff = datetime.utcnow().timestamp() - (older_than_days * 86400)
        deleted = 0

        async for key in self.redis.scan_iter(match=f"{REPORT_PREFIX}*"):
            data = await self.redis.hgetall(key)
            if not data:
                continue

            created_at = data.get("created_at", "")
            if created_at:
                try:
                    created_time = datetime.fromisoformat(created_at).timestamp()
                    if created_time < cutoff:
                        report_id = data.get("id", "")
                        if report_id and await self.delete_report(report_id):
                            deleted += 1
                except ValueError:
                    pass

        return deleted

    def _parse_report(self, data: Dict[str, str]) -> Report:
        """Parse report data from Redis hash.

        Args:
            data: Redis hash data

        Returns:
            Report model
        """
        return Report(
            id=data.get("id", ""),
            tool_name=data.get("tool_name", ""),
            node_id=data.get("node_id") if data.get("node_id") else None,
            edge_id=data.get("edge_id") if data.get("edge_id") else None,
            content=data.get("content", ""),
            metadata=json.loads(data.get("metadata", "{}")) if data.get("metadata") else {},
            created_at=datetime.fromisoformat(data["created_at"]) if data.get("created_at") else datetime.utcnow(),
        )


# Singleton instance
_report_service: Optional[ReportService] = None


def get_report_service() -> ReportService:
    """Get the global report service instance."""
    global _report_service
    if _report_service is None:
        _report_service = ReportService()
    return _report_service
